<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hadoop Data Pipeline Simulator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;800;900&family=Roboto:wght@300;400;500&display=swap');

        /* --- BACKGROUND THEME --- */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* REQUIRED DARK GRADIENT THEME */
            background: radial-gradient(circle at center, #1a2c45, #0b111d) !important;
            font-family: 'Roboto', sans-serif;
            color: white;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* --- UI TITLES --- */
        #main-title {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        #main-title h1 {
            margin: 0;
            font-family: 'Montserrat', sans-serif;
            font-weight: 800;
            font-size: 2rem;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        #main-title p {
            margin: 5px 0 0 0;
            font-size: 0.9rem;
            color: #00eaff;
            font-weight: 400;
            letter-spacing: 1px;
        }

        /* --- PHASE INFO OVERLAY --- */
        #phase-overlay {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #phase-overlay h2 {
            font-family: 'Montserrat', sans-serif;
            color: #ffffff;
            font-size: 1.4rem;
            background: rgba(11, 17, 29, 0.85);
            padding: 10px 30px;
            border-radius: 30px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 234, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 234, 255, 0.15);
            text-transform: uppercase;
        }

        /* --- UI PANEL (Glassmorphism) --- */
        #ui-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 250px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #ui-panel h3 {
            margin: 0 0 10px 0;
            font-size: 0.85rem;
            text-transform: uppercase;
            color: #00eaff;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 8px;
            text-align: center;
            font-family: 'Montserrat', sans-serif;
            letter-spacing: 1px;
            font-weight: 600;
        }

        button {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #ffffff;
            padding: 12px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            font-size: 0.8rem;
            text-align: left;
        }

        button:hover {
            background: rgba(0, 234, 255, 0.15);
            border-color: #00eaff;
            transform: translateX(5px);
            box-shadow: 0 0 15px rgba(0, 234, 255, 0.2);
        }

        button.active {
            background: #00eaff;
            color: #0b111d;
            border-color: #00eaff;
            box-shadow: 0 0 15px rgba(0, 234, 255, 0.5);
        }

        button#btn-reset {
            margin-top: 10px;
            background: rgba(255, 50, 50, 0.15);
            border-color: rgba(255, 50, 50, 0.4);
            text-align: center;
            color: #ffaaaa;
        }
        button#btn-reset:hover {
            background: rgba(255, 50, 50, 0.3);
            color: white;
        }

        /* --- 3D LABELS --- */
        
        /* 1. Base Class */
        .label-3d {
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 10px;
            pointer-events: none;
            text-transform: uppercase;
            white-space: nowrap;
        }

        /* 2. Standard Labels (Nodes, Map Output) - Dark/Neon style */
        .label-dark {
            background: rgba(11, 17, 29, 0.9);
            color: #00eaff;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            border: 1px solid rgba(0, 234, 255, 0.4);
        }

        /* 3. Reduce Label - Gold style */
        .label-reduce { 
            color: #ffd700; 
            border: 1px solid #ffd700; 
            font-size: 12px;
            background: rgba(20, 15, 0, 0.9);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        /* 4. ❗ MANDATORY HIGH VISIBILITY LABELS (Stage 1 & 2) ❗ */
        .label-high-vis {
            background-color: #ffffff !important;
            opacity: 1.0 !important;
            color: #0a1a2a !important;
            font-weight: 900 !important;
            padding: 14px 28px !important;
            border-radius: 12px !important;
            box-shadow: 0 8px 25px rgba(0,0,0,0.35) !important;
            border: 1px solid #e8e8e8 !important;
            z-index: 99999 !important;
            
            /* Additional formatting to ensure text looks good */
            font-size: 13px !important;
            pointer-events: none;
            text-transform: uppercase;
        }

        /* --- BRANDING --- */
        #signature {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-family: 'Montserrat', sans-serif;
            font-size: 0.85rem;
            color: white;
            opacity: 0.6;
            z-index: 20;
            pointer-events: none;
            border-left: 2px solid #00eaff;
            padding-left: 10px;

            @media only screen and (max-width: 768px) {

    /* تصغير اللوحة */
    .control-panel {
        width: 90% !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        padding: 15px !important;
        font-size: 14px !important;
        top: 20px !important;
    }

    /* تصغير الأزرار */
    .panel-button {
        font-size: 14px !important;
        padding: 10px !important;
    }

    /* تصغير العناوين */
    h1, h2, h3 {
        font-size: 18px !important;
        text-align: center !important;
    }

    /* تقليل ارتفاع المنطقة ثلاثية الأبعاد */
    #canvas-container {
        width: 100% !important;
        height: 350px !important;
    }

    /* منع التمرير الجانبي */
    body {
        overflow-x: hidden !important;
    }
}

        }
        
    </style>

    <!-- Import Libraries -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>
</head>
<body>

    <!-- HEADER -->
    <div id="main-title">
        <h1>Hadoop Data Pipeline</h1>
        <p>Interactive 3D Visualization of Big Data Flow</p>
    </div>

    <!-- UI PANEL -->
    <div id="ui-panel">
        <h3>Control Panel</h3>
        <button id="btn-ingest">1. Ingest Data</button>
        <button id="btn-distribute">2. Distribute Blocks</button>
        <button id="btn-map">3. Map Phase</button>
        <button id="btn-shuffle">4. Shuffle Phase</button>
        <button id="btn-reduce">5. Reduce Phase</button>
        <button id="btn-reset">↺ Reset Simulation</button>
    </div>

    <!-- PHASE OVERLAY -->
    <div id="phase-overlay">
        <h2 id="overlay-text">Stage Info</h2>
    </div>

    <!-- WATERMARK -->
    <div id="signature">
        Developed by Dr. Shuhrah Alghamdi
    </div>

    <!-- 3D CANVAS -->
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import gsap from 'gsap';

        // --- Configuration ---
        const CONFIG = {
            colors: {
                source: 0x88ccff,      // Raw data
                hdfs: 0xffffff,        // Transparent Cube
                block: 0x4682b4,       // Steel Blue
                nodeBody: 0xd9d9d9,    // Light Gray PC
                nodeEdge: 0xbfbfbf,    // Dark Gray Edge
                nodeNeon: 0x00eaff,    // Cyan Neon
                keyA: 0x00cc44,        // Green
                keyB: 0xffcc00,        // Yellow
                keyC: 0x9933ff,        // Purple
                gold: 0xf4c542,        // Reduce Result
                path: 0x00eaff         // Path lines
            }
        };

        // --- Globals ---
        let scene, camera, renderer, labelRenderer, controls;
        let sourceGroup, hdfsGroup, computeGroup, reduceGroup;
        let hdfsBox;
        let nodes = [];       
        let resultNode;
        let dataObjects = []; // Particles/Blocks
        let mapParticles = []; // Key-Value pairs
        let connectors = [];  // Visual lines (Shuffle lines & Distribution Paths)
        
        let currentPhase = 0;

        // --- Init ---
        function init() {
            const container = document.getElementById('canvas-container');

            // 1. Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0b111d, 0.012);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 75);

            // 3. Renderer (Alpha true to let CSS gradient show)
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // 4. Label Renderer
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            container.appendChild(labelRenderer.domElement);

            // 5. Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(-20, 50, 30);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 6. Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 120;

            // 7. Build Scene
            buildScene();

            // 8. Event Listeners
            setupButtons();
            window.addEventListener('resize', onWindowResize);

            // 9. Loop
            animate();
        }

        function buildScene() {
            sourceGroup = new THREE.Group();
            hdfsGroup = new THREE.Group();
            computeGroup = new THREE.Group();
            reduceGroup = new THREE.Group();
            scene.add(sourceGroup, hdfsGroup, computeGroup, reduceGroup);

            // --- STAGE 1: Online Data Source (Far Left) ---
            sourceGroup.position.set(-45, 0, 0);
            const iconGeo = new THREE.IcosahedronGeometry(2, 0);
            const iconMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.source, 
                emissive: 0x0044aa,
                emissiveIntensity: 0.8,
                wireframe: true
            });
            const sourceIcon = new THREE.Mesh(iconGeo, iconMat);
            sourceGroup.add(sourceIcon);
            // ❗ HIGH VISIBILITY LABEL APPLIED
            sourceGroup.add(createLabel("ONLINE DATA SOURCE", 0, 3.5, 0, "label-high-vis"));

            // --- STAGE 2: HDFS (Center) ---
            hdfsGroup.position.set(-10, 0, 0);
            const hdfsGeo = new THREE.BoxGeometry(8, 8, 8);
            const hdfsMat = new THREE.MeshBasicMaterial({ 
                color: CONFIG.colors.hdfs, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.15 
            });
            hdfsBox = new THREE.Mesh(hdfsGeo, hdfsMat);
            hdfsGroup.add(hdfsBox);
            // ❗ HIGH VISIBILITY LABEL APPLIED
            hdfsGroup.add(createLabel("HDFS DISTRIBUTED STORAGE", 0, 5.5, 0, "label-high-vis"));

            // --- STAGE 3: Compute Nodes (Computer Towers) ---
            const nodePositions = [
                new THREE.Vector3(10, -5, -12),  // Node 1
                new THREE.Vector3(18, -5, 0),    // Node 2
                new THREE.Vector3(10, -5, 12)    // Node 3
            ];

            nodePositions.forEach((pos, i) => {
                const node = createTower(`NODE ${i+1}`, CONFIG.colors.nodeNeon);
                node.position.copy(pos);
                node.lookAt(0, -5, 0); // Face inward
                computeGroup.add(node);
                nodes.push(node);
            });

            // --- STAGE 7: Reduce Node (Far Right) ---
            resultNode = createTower("REDUCE NODE", CONFIG.colors.gold, true);
            resultNode.position.set(45, -5, 0);
            resultNode.lookAt(18, -5, 0);
            reduceGroup.add(resultNode);
        }

        // --- PROCEDURAL COMPUTER TOWER ---
        function createTower(text, neonColor, isLarge = false) {
            const group = new THREE.Group();

            const w = isLarge ? 4 : 3;
            const h = isLarge ? 7 : 6;
            const d = isLarge ? 5 : 4;

            // Chassis
            const bodyGeo = new THREE.BoxGeometry(w, h, d);
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.nodeBody, 
                roughness: 0.6, 
                metalness: 0.3
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);

            // Edge Lines
            const edges = new THREE.LineSegments(
                new THREE.EdgesGeometry(bodyGeo), 
                new THREE.LineBasicMaterial({ color: CONFIG.colors.nodeEdge })
            );
            group.add(edges);

            // Neon Strip
            const stripGeo = new THREE.BoxGeometry(0.1, h * 0.9, 0.1);
            const stripMat = new THREE.MeshBasicMaterial({ color: neonColor });
            const strip = new THREE.Mesh(stripGeo, stripMat);
            strip.position.set(w/2 + 0.1, 0, d/2 - 0.5); 
            group.add(strip);

            // Glow Light
            const light = new THREE.PointLight(neonColor, 2, 8);
            light.position.set(w/2 + 2, 0, d/2);
            group.add(light);

            // Label
            const cssClass = isLarge ? "label-reduce" : "label-dark";
            const label = createLabel(text, 0, h/2 + 1.2, 0, cssClass);
            group.add(label);

            return group;
        }

        function createLabel(text, x, y, z, className = "label-dark") {
            const div = document.createElement('div');
            div.className = `label-3d ${className}`;
            div.textContent = text;
            const obj = new CSS2DObject(div);
            obj.position.set(x, y, z);
            return obj;
        }

        function updateOverlay(text) {
            const el = document.getElementById('phase-overlay');
            const txt = document.getElementById('overlay-text');
            el.style.opacity = 0;
            setTimeout(() => {
                txt.textContent = text;
                el.style.opacity = 1;
            }, 300);
        }

        // --- STAGE 1: INGEST DATA ---
        function ingestData() {
            if(currentPhase >= 1) return;
            currentPhase = 1;
            setActiveButton('btn-ingest');
            updateOverlay("Online data flowing into Hadoop HDFS");

            // Generate ~40 particles
            for(let i=0; i<42; i++) {
                const geo = new THREE.SphereGeometry(0.25, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.source });
                const p = new THREE.Mesh(geo, mat);
                
                // Randomize near source
                p.position.set(
                    sourceGroup.position.x + (Math.random()-0.5)*5,
                    sourceGroup.position.y + (Math.random()-0.5)*5,
                    sourceGroup.position.z + (Math.random()-0.5)*5
                );
                
                scene.add(p);
                dataObjects.push(p);

                // Destination: Random spot INSIDE HDFS
                const targetX = hdfsGroup.position.x + (Math.random()-0.5)*6;
                const targetY = hdfsGroup.position.y + (Math.random()-0.5)*6;
                const targetZ = hdfsGroup.position.z + (Math.random()-0.5)*6;

                const tl = gsap.timeline();
                // 1. Move Linear
                tl.to(p.position, {
                    x: targetX, y: targetY, z: targetZ,
                    duration: 1.5 + Math.random(),
                    ease: "power2.inOut",
                    delay: Math.random() * 0.5
                });
                
                // 2. Transform to Block
                tl.call(() => {
                    p.geometry.dispose();
                    p.geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    p.material = new THREE.MeshStandardMaterial({ 
                        color: CONFIG.colors.block,
                        roughness: 0.4,
                        metalness: 0.5
                    });
                });
            }
        }

        // --- STAGE 4: BLOCK DISTRIBUTION (CURVED PATHS) ---
        function distributeBlocks() {
            if(currentPhase !== 1) return;
            currentPhase = 2;
            setActiveButton('btn-distribute');
            updateOverlay("Blocks distributed to nodes for parallel processing");

            // Fade HDFS visual
            gsap.to(hdfsBox.material, { opacity: 0.1, duration: 1 });

            dataObjects.forEach((block, i) => {
                const nodeIndex = i % 3; // 1/3 Split logic
                const targetNode = nodes[nodeIndex];
                
                // Setup Orbiting Metadata for later
                block.userData = {
                    node: targetNode,
                    angle: Math.random() * Math.PI * 2,
                    radius: 3.5,
                    speed: 1 + Math.random(),
                    isOrbiting: true,
                    pathProgress: 0
                };

                // --- CURVED PATH LOGIC ---
                const startPos = block.position.clone();
                const endPos = targetNode.position.clone().add(new THREE.Vector3(0, 4, 0)); // Target above node

                // Create control point for curve (High arch)
                const controlPoint = new THREE.Vector3().lerpVectors(startPos, endPos, 0.5);
                controlPoint.y += 15; // Arc height

                const curve = new THREE.QuadraticBezierCurve3(startPos, controlPoint, endPos);

                // DRAW THE PATH (Visible Line)
                const points = curve.getPoints(30);
                const pathGeo = new THREE.BufferGeometry().setFromPoints(points);
                const pathMat = new THREE.LineBasicMaterial({ 
                    color: CONFIG.colors.path, 
                    transparent: true, 
                    opacity: 0.3 
                });
                const pathLine = new THREE.Line(pathGeo, pathMat);
                scene.add(pathLine);
                connectors.push(pathLine); // Store for cleanup

                // ANIMATE along curve
                const tl = gsap.timeline({ delay: i * 0.05 });
                
                tl.to(block.userData, {
                    pathProgress: 1,
                    duration: 2.0,
                    ease: "power2.out", 
                    onUpdate: function() {
                        const pt = curve.getPoint(block.userData.pathProgress);
                        block.position.copy(pt);
                    }
                });
            });
        }

        // --- STAGE 5: MAP PHASE ---
        function mapPhase() {
            if(currentPhase !== 2) return;
            currentPhase = 3;
            setActiveButton('btn-map');
            updateOverlay("Map Phase: Blocks transformed into Key-Value Pairs");

            // Show Labels
            nodes.forEach(n => {
                const lbl = createLabel("MAP OUTPUT", 0, 5, 0, "label-dark");
                n.add(lbl);
                connectors.push(lbl);
            });

            const particleGeo = new THREE.SphereGeometry(0.2, 8, 8);
            const particleMat = new THREE.MeshBasicMaterial();

            dataObjects.forEach(block => {
                // Stop Orbit
                block.userData.isOrbiting = false;
                gsap.to(block.scale, { x:0, y:0, z:0, duration: 0.2 }); // Hide block

                const node = block.userData.node;

                // Spawn 3 KV Particles (Green, Yellow, Purple)
                for(let k=0; k<3; k++) {
                    const p = new THREE.Mesh(particleGeo, particleMat.clone());
                    
                    let color;
                    if(k===0) color = CONFIG.colors.keyA; // Green
                    if(k===1) color = CONFIG.colors.keyB; // Yellow
                    if(k===2) color = CONFIG.colors.keyC; // Purple
                    
                    p.material.color.setHex(color);
                    p.userData = { keyType: k }; // Store Key for Shuffle

                    p.position.copy(node.position);
                    p.position.y += 2; 
                    scene.add(p);
                    mapParticles.push(p);

                    // Eject from front (Z positive relative to node local)
                    gsap.to(p.position, {
                        x: node.position.x + (Math.random()-0.5)*3,
                        y: node.position.y + 3 + (Math.random()-0.5)*3,
                        z: node.position.z + 3 + (Math.random())*2,
                        duration: 0.8,
                        ease: "back.out(2)",
                        delay: Math.random() * 0.3
                    });
                }
            });
        }

        // --- STAGE 6: SHUFFLE PHASE (STRICT SORTING) ---
        function shufflePhase() {
            if(currentPhase !== 3) return;
            currentPhase = 4;
            setActiveButton('btn-shuffle');
            updateOverlay("Shuffle Phase: Grouping Data by Key");

            // Remove Path Lines from distribute phase
            connectors.forEach(c => {
                 if(c.type === 'Line') scene.remove(c);
            });
            connectors = [];

            // 1. Draw Network Mesh Lines
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.1 });
            for(let i=0; i<nodes.length; i++) {
                for(let j=0; j<nodes.length; j++) {
                    if(i !== j) {
                        const pts = [
                            nodes[i].position.clone().setY(-4), 
                            nodes[j].position.clone().setY(-4)
                        ];
                        const geo = new THREE.BufferGeometry().setFromPoints(pts);
                        const line = new THREE.Line(geo, lineMat);
                        scene.add(line);
                        connectors.push(line);
                    }
                }
            }

            // 2. Strict Sorting Animation
            mapParticles.forEach(p => {
                const targetNode = nodes[p.userData.keyType];
                
                gsap.to(p.position, {
                    x: targetNode.position.x + (Math.random()-0.5),
                    y: targetNode.position.y + 5 + (Math.random()-0.5), // Cluster on top
                    z: targetNode.position.z + (Math.random()-0.5),
                    duration: 2.5,
                    ease: "power2.inOut",
                    delay: Math.random() * 0.5,
                    onUpdate: () => {
                        const s = 1 + Math.sin(Date.now()*0.01)*0.3;
                        p.scale.set(s,s,s);
                    }
                });
            });
        }

        // --- STAGE 7: REDUCE PHASE ---
        function reducePhase() {
            if(currentPhase !== 4) return;
            currentPhase = 5;
            setActiveButton('btn-reduce');
            updateOverlay("Reduce Phase: Aggregating Final Result");

            // Cleanup visuals
            connectors.forEach(c => {
                if(c.type === 'Line') gsap.to(c.material, { opacity: 0, duration: 0.5 });
                else if(c.element) c.element.remove(); 
            });

            // Move all to Reduce Node
            mapParticles.forEach(p => {
                gsap.to(p.position, {
                    x: resultNode.position.x,
                    y: resultNode.position.y + 3,
                    z: resultNode.position.z,
                    duration: 2.0,
                    ease: "expo.in",
                    onComplete: () => { p.visible = false; }
                });
            });

            // Spawn Gold Sphere
            setTimeout(() => {
                const sphereGeo = new THREE.SphereGeometry(2.5, 32, 32);
                const sphereMat = new THREE.MeshStandardMaterial({
                    color: CONFIG.colors.gold,
                    emissive: 0xffaa00,
                    emissiveIntensity: 0.5,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const sphere = new THREE.Mesh(sphereGeo, sphereMat);
                sphere.position.set(resultNode.position.x, resultNode.position.y + 8, resultNode.position.z);
                sphere.scale.set(0,0,0);
                scene.add(sphere);
                connectors.push(sphere); // Track for reset

                gsap.to(sphere.scale, { x:1, y:1, z:1, duration: 1.2, ease: "elastic.out(1, 0.5)" });

                // Label
                const resLabel = createLabel("FINAL RESULT", 0, 3.5, 0, "label-reduce");
                sphere.add(resLabel);

                // Pulse
                gsap.to(sphere.scale, { x:1.1, y:1.1, z:1.1, yoyo: true, repeat: -1, duration: 1 });

            }, 1800);
        }

        // --- RESET ---
        function resetSimulation() {
            gsap.globalTimeline.clear();

            // Clear Objects
            dataObjects.forEach(o => scene.remove(o));
            mapParticles.forEach(o => scene.remove(o));
            connectors.forEach(o => {
                scene.remove(o);
                if(o.parent) o.parent.remove(o);
            });

            dataObjects = [];
            mapParticles = [];
            connectors = [];

            // Restore HDFS
            hdfsBox.material.opacity = 0.2;

            // Reset UI
            currentPhase = 0;
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            updateOverlay("");

            // Camera Reset
            gsap.to(camera.position, { x:0, y:20, z:75, duration: 1.5 });
            gsap.to(controls.target, { x:0, y:0, z:0, duration: 1.5 });
        }

        // --- Helpers ---
        function setActiveButton(id) {
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function setupButtons() {
            document.getElementById('btn-ingest').onclick = ingestData;
            document.getElementById('btn-distribute').onclick = distributeBlocks;
            document.getElementById('btn-map').onclick = mapPhase;
            document.getElementById('btn-shuffle').onclick = shufflePhase;
            document.getElementById('btn-reduce').onclick = reducePhase;
            document.getElementById('btn-reset').onclick = resetSimulation;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Rotate Source Icon
            if(sourceGroup && sourceGroup.children[0]) {
                sourceGroup.children[0].rotation.y += 0.005;
                sourceGroup.children[0].rotation.z += 0.003;
            }

            // Rotate HDFS
            if(hdfsBox) hdfsBox.rotation.y += 0.002;

            // Orbit Logic (Active only during Distribute phase, before Map)
            if(currentPhase === 2) {
                const time = Date.now() * 0.001;
                dataObjects.forEach(b => {
                    // Only orbit if path movement finished (pathProgress == 1)
                    if(b.userData.isOrbiting && b.userData.pathProgress >= 1) {
                        const node = b.userData.node;
                        const r = b.userData.radius;
                        const ang = b.userData.angle + time * b.userData.speed;
                        
                        b.position.x = node.position.x + Math.cos(ang) * r;
                        b.position.z = node.position.z + Math.sin(ang) * r;
                        b.lookAt(node.position);
                    }
                });
            }

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        // Run
        init();

    </script>
</body>
</html>
